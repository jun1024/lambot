#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Simple GUI to edit .env, start/stop the DCA Drop-Buy bot and view logs.
- Uses tkinter for GUI
- Saves .env in project root
- Starts bot via subprocess (python bot_dca_exit.py) with environment loaded from .env
- Captures stdout/stderr and shows in GUI log window

Requirements:
- Python 3.8+
- tkinter (builtin)
- If you want fancy .env parsing use python-dotenv (optional). This script can read/write simple KEY=VALUE lines.

Usage:
- Run: python gui.py
"""

import os
import threading
import subprocess
import shlex
import sys
import time
from tkinter import (
    Tk, Frame, Label, Entry, Text, Button, Scrollbar, StringVar, IntVar, Checkbutton, END, DISABLED, NORMAL, filedialog, messagebox
)

# --- Configurable list of environment keys exposed in GUI ---
ENV_KEYS = [
    ("UPBIT_ACCESS_KEY", ""),
    ("UPBIT_SECRET_KEY", ""),
    ("DRY_RUN", "true"),
    ("SIM_KRW_BALANCE", "100000"),
    ("INSTALLMENTS", "5"),
    ("MIN_KRW_ORDER", "5000"),
    ("TOTAL_INVEST_FRACTION", "0.5"),
    ("TOTAL_INVEST_KRW", ""),
    ("DROP_PCT", "2.0"),
    ("DROP_PCT_PER_COIN", "KRW-BTC:2,KRW-ETH:3,KRW-XRP:5"),
    ("INITIAL_BUY", "true"),
    ("MONITOR_INTERVAL_MIN", "5"),
    ("TARGET_PROFIT_PCT", "10"),
    ("TARGET_PROFIT_KRW", ""),
    ("SELL_FRACTION", "1.0"),
    ("PURCHASES_FILE", "purchases.json")
]

ENV_FILE = ".env"
BOT_SCRIPT = "bot_dca_exit.py"  # adjust if file name differs

DEFAULT_ENV_TEMPLATE = """# .env generated by gui.py
UPBIT_ACCESS_KEY=
UPBIT_SECRET_KEY=
DRY_RUN=true
SIM_KRW_BALANCE=100000
INSTALLMENTS=5
MIN_KRW_ORDER=5000
TOTAL_INVEST_FRACTION=0.5
# TOTAL_INVEST_KRW=100000
DROP_PCT=2.0
DROP_PCT_PER_COIN=KRW-BTC:2,KRW-ETH:3,KRW-XRP:5
INITIAL_BUY=true
MONITOR_INTERVAL_MIN=5
TARGET_PROFIT_PCT=10
# TARGET_PROFIT_KRW=5000
SELL_FRACTION=1.0
PURCHASES_FILE=purchases.json
"""

# --- Utilities to read/write .env (simple parser) ---
def load_env_file(path=ENV_FILE):
    env = {}
    if not os.path.exists(path):
        return env
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" in line:
                    key, val = line.split("=", 1)
                    env[key.strip()] = val.strip()
    except Exception:
        pass
    return env

def save_env_file(env_dict, path=ENV_FILE):
    # preserve existing comments minimally by writing keys in ENV_KEYS order and append others
    lines = []
    existing = load_env_file(path)
    written = set()
    for k, default in ENV_KEYS:
        v = env_dict.get(k, existing.get(k, default))
        lines.append(f"{k}={v}")
        written.add(k)
    # add any other keys present
    for k, v in env_dict.items():
        if k not in written:
            lines.append(f"{k}={v}")
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines) + "\n")
        return True
    except Exception as e:
        print("Failed to save .env:", e)
        return False

# --- GUI Application ---
class EnvGui:
    def __init__(self, master):
        self.master = master
        master.title("PAMT - Env Editor & Runner")
        self.env_vars = {}
        self.entries = {}

        # top frame: env fields
        top = Frame(master)
        top.pack(fill="x", padx=8, pady=6)

        # create two columns of entries
        left = Frame(top)
        left.pack(side="left", fill="both", expand=True, padx=(0,8))
        right = Frame(top)
        right.pack(side="left", fill="both", expand=True)

        # load env
        self.env_vars = load_env_file()
        # ensure defaults present
        for k, default in ENV_KEYS:
            if k not in self.env_vars:
                self.env_vars[k] = default

        # create widgets
        for i, (k, _) in enumerate(ENV_KEYS):
            parent = left if i < len(ENV_KEYS)/2 else right
            fr = Frame(parent)
            fr.pack(fill="x", pady=2)
            lbl = Label(fr, text=k, width=22, anchor="w")
            lbl.pack(side="left")
            ent = Entry(fr)
            ent.pack(side="left", fill="x", expand=True)
            ent.insert(0, self.env_vars.get(k, ""))
            self.entries[k] = ent

        # buttons frame
        btn_fr = Frame(master)
        btn_fr.pack(fill="x", padx=8, pady=(4,8))

        self.save_btn = Button(btn_fr, text="Save .env", command=self.save_env)
        self.save_btn.pack(side="left", padx=4)
        self.load_btn = Button(btn_fr, text="Reload .env", command=self.reload_env)
        self.load_btn.pack(side="left", padx=4)
        self.reset_btn = Button(btn_fr, text="Reset to Default Template", command=self.reset_template)
        self.reset_btn.pack(side="left", padx=4)
        self.open_env_btn = Button(btn_fr, text="Open .env File", command=self.open_env_file)
        self.open_env_btn.pack(side="left", padx=4)

        # start/stop controls
        run_fr = Frame(master)
        run_fr.pack(fill="x", padx=8, pady=(0,8))
        self.start_btn = Button(run_fr, text="Start Bot", command=self.start_bot)
        self.start_btn.pack(side="left", padx=4)
        self.stop_btn = Button(run_fr, text="Stop Bot", command=self.stop_bot, state=DISABLED)
        self.stop_btn.pack(side="left", padx=4)
        self.open_purchases_btn = Button(run_fr, text="Open purchases.json", command=self.open_purchases_file)
        self.open_purchases_btn.pack(side="left", padx=4)

        # log area
        log_fr = Frame(master)
        log_fr.pack(fill="both", expand=True, padx=8, pady=(0,8))
        lbl = Label(log_fr, text="Bot Log")
        lbl.pack(anchor="w")
        self.log_text = Text(log_fr, height=20, wrap="none")
        self.log_text.pack(side="left", fill="both", expand=True)
        sb = Scrollbar(log_fr, command=self.log_text.yview)
        sb.pack(side="left", fill="y")
        self.log_text.config(yscrollcommand=sb.set)

        # subprocess handle and thread
        self.proc = None
        self.log_thread = None
        self.stop_log_thread = threading.Event()

        # set window minimum size
        master.minsize(800, 600)

    def reload_env(self):
        env = load_env_file()
        if not env:
            messagebox.showinfo("Reload .env", ".env 파일이 없거나 읽을 수 없습니다.")
            return
        for k in self.entries:
            self.entries[k].delete(0, END)
            self.entries[k].insert(0, env.get(k, ""))
        self.log("Reloaded .env from disk.")

    def save_env(self):
        env = {}
        for k in self.entries:
            env[k] = self.entries[k].get().strip()
        ok = save_env_file(env)
        if ok:
            self.log(".env saved.")
            messagebox.showinfo("Save .env", ".env 파일이 저장되었습니다.")
        else:
            messagebox.showerror("Save .env", "저장에 실패했습니다. 터미널 출력을 확인하세요.")

    def reset_template(self):
        if messagebox.askyesno("Reset .env", "기본 템플릿으로 덮어씌우시겠습니까?"):
            try:
                with open(ENV_FILE, "w", encoding="utf-8") as f:
                    f.write(DEFAULT_ENV_TEMPLATE)
                self.reload_env()
                self.log("Wrote default template to .env")
            except Exception as e:
                messagebox.showerror("Reset .env", f"실패: {e}")

    def open_env_file(self):
        path = os.path.abspath(ENV_FILE)
        if not os.path.exists(path):
            messagebox.showinfo("Open .env", ".env 파일이 존재하지 않습니다.")
            return
        try:
            if sys.platform.startswith("win"):
                os.startfile(path)
            elif sys.platform == "darwin":
                subprocess.Popen(["open", path])
            else:
                subprocess.Popen(["xdg-open", path])
        except Exception:
            messagebox.showinfo("Open .env", f"경로: {path}")

    def open_purchases_file(self):
        path = os.path.abspath(self.entries.get("PURCHASES_FILE", Entry()).get()) if "PURCHASES_FILE" in self.entries else os.path.abspath("purchases.json")
        if not os.path.exists(path):
            messagebox.showinfo("Open purchases.json", "purchases.json 파일이 존재하지 않습니다.")
            return
        try:
            if sys.platform.startswith("win"):
                os.startfile(path)
            elif sys.platform == "darwin":
                subprocess.Popen(["open", path])
            else:
                subprocess.Popen(["xdg-open", path])
        except Exception:
            messagebox.showinfo("Open purchases.json", f"경로: {path}")

    def log(self, text):
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        try:
            self.log_text.insert(END, f"[{timestamp}] {text}\n")
            self.log_text.see(END)
        except Exception:
            pass

    def start_bot(self):
        # Save env first
        self.save_env()
        # prepare env for subprocess
        env = os.environ.copy()
        file_env = load_env_file()
        for k, v in file_env.items():
            env[k] = v

        # check BOT_SCRIPT exists
        if not os.path.exists(BOT_SCRIPT):
            messagebox.showerror("Start Bot", f"Bot script not found: {BOT_SCRIPT}")
            return

        # start subprocess
        cmd = [sys.executable, BOT_SCRIPT]
        try:
            self.proc = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                bufsize=1,
                universal_newlines=True,
                env=env
            )
        except Exception as e:
            messagebox.showerror("Start Bot", f"프로세스를 시작할 수 없습니다: {e}")
            return

        self.start_btn.config(state=DISABLED)
        self.stop_btn.config(state=NORMAL)
        self.log(f"Started bot: {cmd}")
        self.stop_log_thread.clear()
        self.log_thread = threading.Thread(target=self._read_process_output, daemon=True)
        self.log_thread.start()

    def _read_process_output(self):
        try:
            for line in self.proc.stdout:
                if line is None:
                    break
                self.log(line.rstrip())
                if self.stop_log_thread.is_set():
                    break
        except Exception as e:
            self.log(f"Log reader exception: {e}")
        finally:
            self._on_process_end()

    def _on_process_end(self):
        # Called when process ends or log thread finishes
        self.stop_log_thread.set()
        if self.proc:
            try:
                ret = self.proc.poll()
                if ret is None:
                    # try terminate
                    try:
                        self.proc.terminate()
                    except Exception:
                        pass
                self.log(f"Bot process ended (returncode={self.proc.returncode})")
            except Exception:
                pass
        self.proc = None
        self.start_btn.config(state=NORMAL)
        self.stop_btn.config(state=DISABLED)

    def stop_bot(self):
        if not self.proc:
            return
        if messagebox.askyesno("Stop Bot", "봇을 중지하시겠습니까?"):
            try:
                self.proc.terminate()
                # wait briefly
                try:
                    self.proc.wait(timeout=5)
                except Exception:
                    try:
                        self.proc.kill()
                    except Exception:
                        pass
                self.log("Sent terminate to bot process.")
            except Exception as e:
                self.log(f"Failed to terminate process: {e}")
            finally:
                self._on_process_end()

def main():
    root = Tk()
    app = EnvGui(root)
    root.mainloop()

if __name__ == "__main__":
    main()